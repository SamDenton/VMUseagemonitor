//First section is functions building data structures and populating arrays from file
//Second section is misc functions called by multiple pages
//Third fourth and fifth sections are for functions called by a specific page
//Maybe should re-arange functions to be in order of when they are called?

//Read files and build array:

//Declare global array for all VM info, and a second for server status
let VMDetail;
let serverStatus;

//declare path for read write functions.  Can swap between tmpPath and localPath in 'readUserPath()' function
//Change must be made in this file, and VM_Manager_Main.bat
//tmpPath is set to users %tmp% location
//Local path with save temp files in data folder.  Will work fine if its a single user at a time.
let mainPath;
let localPath = 'Data';

let firstRun = 0;

function readUserPath() {
	var Path = 'Data\\currentUserTempPath.txt';
	var fso = new ActiveXObject('Scripting.FileSystemObject');
	iStream = fso.OpenTextFile(Path, 1, true);
	while (!iStream.AtEndOfStream) {
		userPath = iStream.readLine();
	}
	iStream.close();
	//userPath = userPath.replace(/\\/g, "\\\\");
	tmpPath = userPath + '\\appdata\\local\\temp';

	//Swap here between local and user TMP path

	//mainPath = localPath;
	mainPath = tmpPath;
}
//Read serverList.txt and populate VM lists
function readVMDetail(MainOrAdd) {
	//Initialize global array with 2 example VMs.  Might remove these
	VMDetail = [['Head Office 1', '192.168.80.2', 'test', 'test'], ['Branch 1 of HO 1', '192.168.80.3', 'test', 'test']];
	serverStatus = ['Available', 'Available'];
	var svrPath = "Data\\serverList.txt";
	var svrfso = new ActiveXObject('Scripting.FileSystemObject');
	svriStream = svrfso.OpenTextFile(svrPath, 1, true);
	let m = 0;
	var svrline = [];
	var VMObject = [];
	//This does not need to be a do while but it was useful during testing to force through the first line
	do {
		let lineCheck = svriStream.readLine();
		//Read file line by line and add each line as an array element
		//Don't really need these checks anymore as text file is generated by program
		if (lineCheck != null || lineCheck != " " || lineCheck != "") {
			svrline[m] = lineCheck;
			m++
		}
	} while (!svriStream.AtEndOfStream);
	svriStream.Close();
	for (let n = 1; n < svrline.length; n++) {
		//Split each array element into an array on each comma, making a multidimensional array
		VMObject = svrline[n].split(",");
		VMDetail.push(VMObject);
		serverStatus.push('Available');
	}
	if (MainOrAdd == 'add') return;
	addCreds();
}
//Create batch script to inject credentials.  Windows needs creds to query server status
function addCreds() {
	var fso = new ActiveXObject("Scripting.FileSystemObject");
	//var write_id = '\data\\WinCreds.bat';
	var path = 'data\\WinCreds.bat';
	var s = fso.OpenTextFile(path, 2, true);
	s.WriteLine('@echo off & setlocal');
	for (let i = 0; i < VMDetail.length; i++) {
		//One credential type allows CMD to query a server, and the other allows you to connect without being prompted for creds
		s.WriteLine('cmdkey /add:' + VMDetail[i][1] + ' /user:' + VMDetail[i][2] + ' /pass:' + VMDetail[i][3] + '');
		s.WriteLine('cmdkey /generic:' + VMDetail[i][1] + ' /user:' + VMDetail[i][2] + ' /pass:' + VMDetail[i][3] + '');
	}
	s.WriteLine('del /q ' + 'data\\WinCreds.bat');
	s.WriteLine('exit /b');
	s.Close();
	runBat3();
}
//Run created bat for credential injection
function runBat3() {
	var path = 'data\\WinCreds.bat';
	var MyObject = new ActiveXObject("wscript.shell");
	MyObject.Run(path, 0);
}
//Attempt to re-write these functions to be more general and move most logic to JS
function checkStatus() {
	var path = mainPath;

	for (let i = 0; i < VMDetail.length; i++) {
		var fso = new ActiveXObject("Scripting.FileSystemObject");
		var write_id = path + '\\checkVM' + [i] + '.bat';
		var s = fso.OpenTextFile(write_id, 2, true);
		s.WriteLine('@echo off & setlocal');
		//Change directory to tmp since batch opens in the folder the program which ran it was opened from, not where the batch file is located
		s.WriteLine('cd /d ' + path);
		s.WriteLine('echo Loading > loaded' + [i] + '.txt');
		//Qwinsta queries a server using RPC protocols, returns a list of sessions and states 
		s.WriteLine('qwinsta /server:' + VMDetail[i][1] + ' > srv' + [i] + 'qwinsta.txt 2>&1');
		//set loading file to loaded
		s.WriteLine('echo Loaded > loaded' + [i] + '.txt');
		s.WriteLine('exit /b');
		s.Close();
	}
	//Create second bat to start main program once loading is complete
	var fso2 = new ActiveXObject("Scripting.FileSystemObject");
	var write_id2 = mainPath + '\\start.bat';
	var s2 = fso.OpenTextFile(write_id2, 2, true);
	s2.WriteLine('@echo off & setlocal');
	//s2.WriteLine('echo msgbox "Batch loop" > %temp%\popup.vbs');
    //s2.WriteLine('wscript.exe "%temp%\popup.vbs"');
	s2.WriteLine('start /min data\\VM_Manager_Main.bat');
	s2.WriteLine('exit /b');
	s2.Close();
	runBat2();
	//wait a second to allow batch to run before trying to read file
	setTimeout(checkLoading, 1000);
}
//Run the batch file to write the availability file
function runBat2() {
	for (let i = 0; i < VMDetail.length; i++) {
		var MyObject = new ActiveXObject("wscript.shell");
		MyObject.Run(mainPath + '\\checkVM' + [i] + '.bat', 0);
	}
}
//Read the 'srv[i]qwinsta.txt' and split into tokens for users and their status
function checkUsage(running) {
	var path = mainPath;
	//I'm no longer using these loop markers but I'll keep them for symentics.  
	Loop1:
	for (let i = 0; i < VMDetail.length; i++) {
		let activeUsers = [];
		let userStatus = [];
		let inputQwinsta = [];
		let arrayType = 0;
		var readPath = path + '\\srv' + [i] + 'qwinsta.txt';
		let m = 0;
		var fso = new ActiveXObject('Scripting.FileSystemObject');
		iStream = fso.OpenTextFile(readPath, 1, false);
		while (!iStream.AtEndOfStream) {
			inputQwinsta[m] = iStream.readLine();
			m++;
		}
		iStream.Close();

		/*
		Could possibly move some of this logic to the initial batch query, something like:

			FOR /F "tokens=2,3" %i IN ('qwinsta /server:serverName ^| findstr "Active"') DO @echo %i | findstr /v "[a-z]" && rwinsta echo %i > test.txt

		This should save just the user names to the text file, but qwinsta does not always populate the first token, so need some logic to split the tokens properly 
		*/

		//Split each element (line) of the inputQwinsta array into its own array, splitting on each space.  Creates a multidimentional array.  Messy output since qwinsta can produce blank results in some fields
		for (let n = 0; n < inputQwinsta.length; n++) {
			inputQwinsta[n] = '!' + inputQwinsta[n].substring(1);
			inputQwinsta[n] = inputQwinsta[n].split(/\s+/);
		}
		//Clean up output from last loop by getting rid of any lines containing the following strings.  Previously was splicing to remove line, but works better if i replace with marker.
		for (let o = 0; o < inputQwinsta.length; o++) { 
			if (inputQwinsta[o][0] == '!SESSIONNAME' || inputQwinsta[o][0] == '!services' || inputQwinsta[o][0] == '!console' || inputQwinsta[o][3] == 'Listen' || inputQwinsta[o][2] == 'Listen') {
				inputQwinsta[o] = 'ignore';
				//inputQwinsta.splice(o, 1);
            }
		}
		Loop2:
		for (let k = 0; k < inputQwinsta.length; k++) {
			//Check the 4th token of qwinsta to see if there are any active users
			if (inputQwinsta[k][3] == 'Active') {
				//If function finds blank row before and active user, it will set server to 'not in use'.  If it then finds an active user, it overwrites this.
				if (arrayType == 3) {
					activeUsers.length = 0;
					activeUsers.push(inputQwinsta[k][1]);
					userStatus.push('Active');
					arrayType = 1;
				}
                else {
					activeUsers.push(inputQwinsta[k][1]);
					userStatus.push('Active');
					arrayType = 1;
                }
			}
			//Look for disconnected users and idle users.  Still adds them to active user list, but notes they are not in use.
			else if (inputQwinsta[k][3] == 'Disc' /* && inputQwinsta[k][2] !== " " && inputQwinsta[k][2] */) {
				if (arrayType == 3) {
					activeUsers.length = 0;
					activeUsers.push(inputQwinsta[k][1]);
					userStatus.push('Session Exists But Disconnected');
					arrayType = 1;
				}
				else {
					activeUsers.push(inputQwinsta[k][1]);
					userStatus.push('Session Exists But Disconnected');
					arrayType = 1;
				}
			}
			else if (inputQwinsta[k][3] == 'Idle' /* && inputQwinsta[k][2] !== " " && inputQwinsta[k][2] */) {
				if (arrayType == 3) {
					activeUsers.length = 0;
					activeUsers.push(inputQwinsta[k][1]);
					userStatus.push('Session Exists But Idle');
					arrayType = 1;
				}
				else {
					activeUsers.push(inputQwinsta[k][1]);
					userStatus.push('Session Exists But Idle');
					arrayType = 1;
				}
			}
			else if (inputQwinsta[0][1] == '1722') {
				activeUsers.length = 0;
				userStatus.length = 0;
				activeUsers.push('Offline or Protected Against RPC');
				arrayType = 2;
			}
			else if (inputQwinsta[0][1] == 'denied') {
				activeUsers.length = 0;
				userStatus.length = 0;
				activeUsers.push('Access is Denied, Check RPC Settings in Regedit');
				arrayType = 2;
			}
			else {
				if (arrayType == 0) {
					activeUsers.length = 0;
					activeUsers.push('Connection Not In Use');
					arrayType = 3;
					//break Loop2;
				}
			}
		}
		if (running != 'fromMain') {
			var fso = new ActiveXObject("Scripting.FileSystemObject");
			var write_id = path + '\\svr' + [i] + 'availability.txt';
			var s = fso.OpenTextFile(write_id, 2, true);

			if (arrayType == 1) {
				s.WriteLine('Connection In Use, Usernames: ');
				for (let e = 0; e < activeUsers.length; e++) {
					s.WriteLine(activeUsers[e] + ': ' + userStatus[e]);
				}
				serverStatus[i] = 'In Use';
			}
			else if (arrayType == 2) {
				s.WriteLine('Connection Not Made:  ');
				s.WriteLine(activeUsers);
				serverStatus[i] = 'Unavailable';
			}
			else {
				s.WriteLine(activeUsers);
				serverStatus[i] = 'Available';
			}
			s.Close();
		}
		else {
			if (arrayType == 1) {
				serverStatus[i] = 'In Use';
			}
			else if (arrayType == 2) {
				serverStatus[i] = 'Unavailable';
			}
			else {
				serverStatus[i] = 'Available';
			}
        }
	}
	if (running != 'refresh' && running != 'fromMain') {
		var MyObject = new ActiveXObject("wscript.shell");
		MyObject.Run(mainPath + '\\start.bat', 0);
		window.close();
    }
}
//Count lines of 'loaded' from file until it matches VMDetail.length
function checkLoading(isRunning) {
	var count = 0;
	for (let m = 0; m < VMDetail.length; m++) {
		var path = mainPath + '\\loaded' + [m] + '.txt';
		var fso = new ActiveXObject('Scripting.FileSystemObject');
		iStream = fso.OpenTextFile(path, 1, false);
		while (!iStream.AtEndOfStream) {
			if (iStream.ReadLine() == 'Loaded ') {
				count++;
			}
		}
		iStream.Close();
	}
	if (count < VMDetail.length) {
		//check the loading file every half a second
		if (isRunning == 'refreshBTN') {
			setTimeout(function () { checkLoading('refreshBTN'); }, 500);
		}
		else {
			setTimeout(checkLoading, 500);
        }
	}
	else {
		//Once data is loaded, see if function was called by refresh button or first running program.  If it was refresh, tell checkUsage function not to start main program again
		if (isRunning == 'refreshBTN') {
			//Hide the loading spinner
			document.getElementById("buttonLoader").style.animationPlayState = 'paused';
			document.getElementById("buttonLoader").style.display = 'none';
			//Call session checker after loaded files are found
			checkUsage('refresh');
			testConnection();
		}
        else {
			checkUsage();	
			testConnection();
        }
		return;
	}
}

//Function to populate table with VMs and connection buttons
function startUp() {
	//Hide loading spinner
	document.getElementById("buttonLoader").style.animationPlayState = 'paused';
	document.getElementById("buttonLoader").style.display = 'none';

	//This loop is dynamically adding rows to the table based on the input array
	for (let i = 0; i < VMDetail.length; i++) {
		var newRow = document.getElementById('MainList').insertRow();
		var newCell = newRow.insertCell();
		newCell.innerHTML = '<tr><td>' + VMDetail[i][1] + ' <button class="btn btn-outline-primary" onclick="writeBat(' + [i] + ');">Connect</button></td>';
		newCell = newRow.insertCell();
		newCell.innerHTML = '<td>' + VMDetail[i][0] + '</td>';
		newCell = newRow.insertCell();
		newCell.innerHTML = '<td><div id=\'Marker' + [i] + '\'></div></td></tr>';
	}
	//Add a further row with the 'add VM' button
	var newRow2 = document.getElementById('MainList').insertRow();
	var newCell = newRow2.insertCell();
	newCell.innerHTML = '<tr><td>Manage VM List <button class="btn btn-outline-primary" onclick="addNew();">Manage</button></td>';
	newCell = newRow2.insertCell();
	newCell.innerHTML = '<td>...</td>';
	newCell = newRow2.insertCell();
	newCell.innerHTML = '<td>...</td></tr>';
}
//Runs checkVM bats to update availability file.  Could switch to updating every 30 seconds or so
function refresh() {
	//Show loading spinner
	document.getElementById("buttonLoader").style.display = '';
	document.getElementById("buttonLoader").style.animationPlayState = 'running';
	var MyObject = new ActiveXObject("wscript.shell");
	for (let i = 0; i < VMDetail.length; i++) {
		//Run the already created check VM scripts
		MyObject.Run(mainPath + '\\checkVM' + [i] + '.bat', 0);
	}
	//Wait for loading files to generate then start checking if loading is complete
	setTimeout(function () { checkLoading('refreshBTN'); }, 1000);
}

//read availability file into an array.  Could have this trigger from checkLoading() function  
function testConnection() {
	for (let n = 0; n < VMDetail.length; n++) {
		document.getElementById('Marker' + [n]).innerHTML = '';
		//read each availability file into 1 array
		var path = mainPath + '\\svr' + [n] + 'availability.txt';
		var fso = new ActiveXObject('Scripting.FileSystemObject');
		iStream = fso.OpenTextFile(path, 1, false);
		var line = [];
		let count = 0;
		while (!iStream.AtEndOfStream) {
			line[count] = iStream.ReadLine();
			count++;
		}
		for (let i = 0; i < line.length; i++) {
			//update status in table
			document.getElementById('Marker' + [n]).innerHTML += line[i] + '<br>';
		}
	}
	iStream.Close();
	//Check for updates every 5 Mins
	setTimeout(refresh, 300000);
}
//write bat file to connect to correct server after checking if the chosen server is not in use
function writeBat(svrNo) {
	var connectToInUse;
	var connectToUnavailable;
	var connectToAvailable;
	var svrAddress;
	if (serverStatus[svrNo] == 'In Use') {
		connectToInUse = confirm(VMDetail[svrNo][0] + " is already in use, do you want to connect anyway?");
		if (connectToInUse == true) {
			svrAddress = VMDetail[svrNo][1];
		}
		else {
			return;
		}
	}
	else if (serverStatus[svrNo] == 'Unavailable') {
		connectToUnavailable = confirm("The server at '" + VMDetail[svrNo][1] + "' is not responding, do you want to try connecting anyway?");
		if (connectToUnavailable == true) {
			svrAddress = VMDetail[svrNo][1];
		}
		else {
			return;
		}
    }
	else {
		connectToAvailable = confirm("Connect to '" + VMDetail[svrNo][0] + "'?");
		if (connectToAvailable == true) {
			svrAddress = VMDetail[svrNo][1];
		}
		else {
			return;
		}
	}
	//Write a batch file to open RDP connection to VM
	//Since this is using VBScript, I need to be careful about version compatibility
	//MSHTA is either compatible with IE version > 9 or VBScript but not both
	//Since the containing MSHTA is set to IE version 'edge', the VBscript needs its own HTA:
	//Another good example of why I should be using powerscript
	var fso = new ActiveXObject("Scripting.FileSystemObject");
	var write_id = mainPath + '\\makeConnection.bat';
	var s = fso.OpenTextFile(write_id, 2, true);
	s.WriteLine('@echo off & setlocal');
	s.WriteLine('set svrID=' + svrAddress);
	//s.WriteLine('call :MsgBox "connecting to %svrID%"');
	s.WriteLine('start mstsc /v:%svrID%');
	s.WriteLine('exit /b');
	s.WriteLine(':MsgBox prompt type title');
	s.WriteLine('    setlocal enableextensions');
	s.WriteLine('    set "tempFile=%temp%\%~nx0.%random%%random%%random%vbs.tmp"');
	s.WriteLine('    >"%tempFile%" echo(WScript.Quit msgBox("%~1",%~2,"%~3") & cscript //nologo //e:vbscript "%tempFile%"');
	s.WriteLine('    set "exitCode=%errorlevel%" & del "%tempFile%" >nul 2>nul');
	s.WriteLine('    endlocal & exit /b %exitCode%');
	s.Close();
	runBat();
}
// Run the Bat file to connect to the server
function runBat() {
	var MyObject = new ActiveXObject("wscript.shell");
	MyObject.Run(mainPath + '\\makeConnection.bat',0);
	setTimeout(delBat, 5000);
}
//After 5 seconds, delete the connection bat file
function delBat() {
	var myObject = new ActiveXObject("Scripting.FileSystemObject");
	myObject.DeleteFile(mainPath + '\\makeConnection.bat');
}
//Run batch to open the server management UI
function addNew() {
	var MyObject = new ActiveXObject("wscript.shell");
	MyObject.Run("data\\addNewVM.bat",0);
	window.close();
}
//Read what is currently typed into input boxes
//This has some basic input validation but need it to also escape or ignore special chars to prevent injection
//Most of this code is just adding and removing style classes to update the color of the input boxes!
function insertVM() {
	let formValidation = 'valid';
	let VMNameValidation = document.getElementById('newName');
	if (!VMNameValidation.checkValidity()) {
		document.getElementById("nameValidation").innerHTML = VMNameValidation.validationMessage;
		VMNameValidation.classList.remove("is-valid");
		VMNameValidation.classList.add("is-invalid");
		formValidation = 'invalid';
	}
	else {
		var newVMName = document.getElementById('newName').value;
		document.getElementById("nameValidation").innerHTML = "";
		VMNameValidation.classList.remove("is-invalid");
		VMNameValidation.classList.add("is-valid");
	}
	let VMIPValidation = document.getElementById('newIP');
	//Check the IP address follows standard format
	var ipformat = /^(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/;
	if (!VMIPValidation.checkValidity()) {
		document.getElementById("IPValidation").innerHTML = VMIPValidation.validationMessage;
		VMIPValidation.classList.remove("is-valid");
		VMIPValidation.classList.add("is-invalid");
		formValidation = 'invalid';
	}
	else if (!VMIPValidation.value.match(ipformat)) {
		document.getElementById("IPValidation").innerHTML = "That is not a valid IP address";
		VMIPValidation.classList.remove("is-valid");
		VMIPValidation.classList.add("is-invalid");
		formValidation = 'invalid';
	}
	else {
		var newVMIP = document.getElementById('newIP').value;
		document.getElementById("IPValidation").innerHTML = "";
		VMIPValidation.classList.remove("is-invalid");
		VMIPValidation.classList.add("is-valid");
	}
	let VMUserValidation = document.getElementById('newUsername');
	if (!VMUserValidation.checkValidity()) {
		document.getElementById("userValidation").innerHTML = VMUserValidation.validationMessage + ': Use a space for Username if unknown';
		VMUserValidation.classList.remove("is-valid");
		VMUserValidation.classList.add("is-invalid");
		formValidation = 'invalid';
	}
	else {
		var newVMUsername = document.getElementById('newUsername').value;
		document.getElementById("userValidation").innerHTML = 'Use a space for Username if unknown';
		VMUserValidation.classList.remove("is-invalid");
		VMUserValidation.classList.add("is-valid");
	}
	let VMPassValidation = document.getElementById('newPassword');
	if (!VMPassValidation.checkValidity()) {
		document.getElementById("passValidation").innerHTML = VMPassValidation.validationMessage + ': Use a space for Password if unknown/security risk';
		VMPassValidation.classList.remove("is-valid");
		VMPassValidation.classList.add("is-invalid");
		formValidation = 'invalid';
	}
	else {
		var newVMPassword = document.getElementById('newPassword').value;
		document.getElementById("passValidation").innerHTML = 'Use a space for Password if unknown/security risk';
		VMPassValidation.classList.remove("is-invalid");
		VMPassValidation.classList.add("is-valid");
	}
	if (formValidation == 'valid') {
		//Assuming the input is valid, clear the input boxes and remove validity flags
		document.getElementById("newName").value = "";
		document.getElementById("newIP").value = "";
		document.getElementById("newUsername").value = "";
		document.getElementById("newPassword").value = "";
		VMNameValidation.classList.remove("is-valid");
		VMIPValidation.classList.remove("is-valid");
		VMUserValidation.classList.remove("is-valid");
		VMPassValidation.classList.remove("is-valid");
		//Write the 4 strings to 1 line of serverList.txt with comma separation
		var path = "Data\\serverList.txt";
		var fso = new ActiveXObject("Scripting.FileSystemObject");
		s = fso.OpenTextFile(path, 8, false);
		s.WriteLine('' + newVMName + ',' + newVMIP + ',' + newVMUsername + ',' + newVMPassword + '');
		s.Close();

		resetVMTable();
	}
	else {
		//Could add a custom message box here rather than an alert
		alert('The details entered are not valid');
	}
}
//Remove all rows from the table then rebuild with updated VM list
function resetVMTable() {
	readVMDetail('add');
	var table = document.getElementById('MainList');
	tableLength = table.tBodies[0].rows.length;
	for (let i = 0; i < tableLength; i++) {
		var removeRow = document.getElementById('row' + [i]);
		removeRow.parentNode.removeChild(removeRow);
	}
	buildCurrentVMTable();
}
//Build table from VMDetail, including button to remove VM
function buildCurrentVMTable() {
	for (let i = 0; i < VMDetail.length; i++) {
		var newRow = document.getElementById('MainList').insertRow();
		newRow.id = 'row' + [i];
		var newCell = newRow.insertCell();
		newCell.innerHTML = '<tr><td>' + VMDetail[i][1] + ' <button class="btn btn-outline-primary" onclick="removeVM(' + [i] + ');">Remove</button></td>';
		newCell = newRow.insertCell();
		newCell.innerHTML = '<td>' + VMDetail[i][0] + '</td></tr>';
	}
}
//Remove selected VM, checking its not one of the example VMs
function removeVM(VMNo) {
	if (VMNo > 2) {
		//VMNo here will refer to position in table, so need to -2 for 2 default VMs, but +1 for the header.  So:
		let vmToRemove = VMNo - 1;
		var path = "Data\\serverList.txt";
		var fso = new ActiveXObject("Scripting.FileSystemObject");
		r = fso.OpenTextFile(path, 1, false);
		let i = 0;
		let currentList = [];
		//Read whole current serverList.txt file line by line into temp array
		while (!r.AtEndOfStream) {
			currentList[i] = r.ReadLine();
			i++;
		}
		r.close();
		//Remove chosen VM from temp array
		currentList.splice(vmToRemove, 1);
		var fso2 = new ActiveXObject("Scripting.FileSystemObject");
		w = fso2.OpenTextFile(path, 2, false);
		for (let n = 0; n < currentList.length; n++) {
			//Re-write serverList.txt with remaining VMs
			w.WriteLine(currentList[n]);
		}
		w.close();
		//Run reset function to update UI
		resetVMTable();
	}
	else {
		alert('You cant remove the example VMs (HO 1 and Branch 1 of HO 1)');
	}
}
//when return button is pressed, open main program and close window
function exitAndReturn() {
	addCreds();
	backToProgram();
	window.close();
}
//Open main program.  Split into separate function so I could have main program launch on any exit type (x, alt+f4, crash, task manager etc) if wanted.  
function backToProgram() {
	var MyObject = new ActiveXObject("wscript.shell");
	MyObject.run('VM_Manager.bat',0);
}

